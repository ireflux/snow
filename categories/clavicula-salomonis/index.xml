<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Clavicula Salomonis on sherry's blog</title><link>https://ireflux.github.io/snow/categories/clavicula-salomonis/</link><description>Recent content in Clavicula Salomonis on sherry's blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 22 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ireflux.github.io/snow/categories/clavicula-salomonis/index.xml" rel="self" type="application/rss+xml"/><item><title>WeeChat 的使用指南</title><link>https://ireflux.github.io/snow/post/weechat-guide/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/weechat-guide/</guid><description>&lt;p>前几天看了霍矩大佬做的一期关于 Clubhouse 视频，其中提到了 &lt;a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">IRC&lt;/a> 这种古老的通信协议，视频中还说到 IRC 这种如今带有匿名性质的聊天室，因规模较小，审查成本较高，可能是互联网上的最后一方净土，这也正好是我感兴趣的地方 :)&lt;/p>
&lt;p>从 &lt;a href="https://wiki.archlinux.org/index.php/List_of_applications/Internet#IRC_clients">arch wiki&lt;/a> 中可以找到一些主流的支持 IRC 协议的软件。根据 下面的图表对比，&lt;a href="https://WeeChat.org/">WeeChat&lt;/a> 相比于其他软件来说扩展性最好，最有优势。&lt;/p>
&lt;p>下图表搬运自 arch wiki：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Name&lt;/th>
&lt;th style="text-align:center">Package&lt;/th>
&lt;th style="text-align:center">Written in&lt;/th>
&lt;th style="text-align:center">Extensible&lt;/th>
&lt;th style="text-align:center">&lt;a href="https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer">SASL&lt;/a>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">BitchX&lt;/td>
&lt;td style="text-align:center">bitchx-git&lt;/td>
&lt;td style="text-align:center">C&lt;/td>
&lt;td style="text-align:center">?&lt;/td>
&lt;td style="text-align:center">?&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ERC&lt;/td>
&lt;td style="text-align:center">emacs&lt;/td>
&lt;td style="text-align:center">ELisp&lt;/td>
&lt;td style="text-align:center">in ELisp&lt;/td>
&lt;td style="text-align:center">via script&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ii&lt;/td>
&lt;td style="text-align:center">iiAUR&lt;/td>
&lt;td style="text-align:center">C&lt;/td>
&lt;td style="text-align:center">stdin/stdout&lt;/td>
&lt;td style="text-align:center">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Irssi&lt;/td>
&lt;td style="text-align:center">irssi&lt;/td>
&lt;td style="text-align:center">C&lt;/td>
&lt;td style="text-align:center">in Perl&lt;/td>
&lt;td style="text-align:center">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">pork&lt;/td>
&lt;td style="text-align:center">pork&lt;/td>
&lt;td style="text-align:center">C&lt;/td>
&lt;td style="text-align:center">in Perl&lt;/td>
&lt;td style="text-align:center">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ScrollZ&lt;/td>
&lt;td style="text-align:center">scrollz&lt;/td>
&lt;td style="text-align:center">C&lt;/td>
&lt;td style="text-align:center">?&lt;/td>
&lt;td style="text-align:center">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">sic&lt;/td>
&lt;td style="text-align:center">sicAUR&lt;/td>
&lt;td style="text-align:center">C&lt;/td>
&lt;td style="text-align:center">stdin/stdout&lt;/td>
&lt;td style="text-align:center">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">tiny&lt;/td>
&lt;td style="text-align:center">tiny-irc-client-git&lt;/td>
&lt;td style="text-align:center">Rust&lt;/td>
&lt;td style="text-align:center">No&lt;/td>
&lt;td style="text-align:center">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">WeeChat&lt;/td>
&lt;td style="text-align:center">WeeChat&lt;/td>
&lt;td style="text-align:center">C&lt;/td>
&lt;td style="text-align:center">multiple languages&lt;/td>
&lt;td style="text-align:center">Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Elasticsearch 入门 | 一</title><link>https://ireflux.github.io/snow/post/study-notes-of-elasticsearch-1/</link><pubDate>Mon, 23 Mar 2020 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/study-notes-of-elasticsearch-1/</guid><description>&lt;p>本文是我开始学习 Elasticsearch 系列的第一篇笔记，计划先以我初学者的状态对 Elasticsearch 的看法以及目前学到的知识做个概览性的总结，之后的系列再单独对其细节专门去学习和记录，留备后期翻阅查看。&lt;/p>
&lt;p>注：截至本文发表前，Elasticsearch 的版本号为 7.6.1，本文的内容也建立于此之上。&lt;/p>
&lt;h2 id="elasticsearch-是什么">Elasticsearch 是什么？&lt;/h2>
&lt;p>根据官方文档和 Wikipedia 的说法：&lt;/p>
&lt;p>Elasticsearch是一个基于Apache Lucene构建的分布式的开源搜索和分析引擎，可以处理所有类型的数据，包括文本，数字，地理空间，结构化和非结构化的数据。&lt;/p></description></item><item><title>netcat 的使用笔记</title><link>https://ireflux.github.io/snow/post/netcat-note/</link><pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/netcat-note/</guid><description>&lt;p>当在&lt;a href="https://packages.debian.org/sid/netcat-openbsd"> debian 的仓库&lt;/a>中查看 openbsd 版本的 netcat时，会看到描述中有这样一句话：“TCP/IP swiss army knife”，被誉为 TCP/IP 的瑞士军刀，可以想象，这可以说是很高的赞誉了。netcat 当年还是2001年，2003年，2006年的 insecure.org 几次安全工具的投票中的前五名，它不仅是一个非常优秀的软件，体积还很小（只有几十KB），&lt;a href="https://github.com/openbsd/src/tree/master/usr.bin/nc">源代码&lt;/a> 也很少，以至于有很多人去重写，出现了很多变种。比较知名的有&lt;a href="https://packages.debian.org/sid/netcat-openbsd">openbsd版本&lt;/a>，&lt;a href="http://netcat.sourceforge.net/download.php">gnu版本&lt;/a>，&lt;a href="https://nmap.org/ncat/">nmap社区版本ncat&lt;/a>。&lt;/p></description></item><item><title>使用 Github Actions 每天自动发送比特币的估值邮件</title><link>https://ireflux.github.io/snow/post/send-mail-with-bitcoin-rate-everyday/</link><pubDate>Tue, 24 Dec 2019 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/send-mail-with-bitcoin-rate-everyday/</guid><description>&lt;p>前段时间，在阮一峰老师那里看到了&lt;a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程&lt;/a>，于是自己也跑去申请了体验资格，然而玩了一下感觉太复杂就放弃了。时隔数日，Github Actions 正式发布了，阮老师又发布了一篇关于此的文章：&lt;a href="http://www.ruanyifeng.com/blog/2019/12/github_actions.html">GitHub Actions 教程：定时发送天气邮件&lt;/a>，这又让我想起了这个功能，于是决定重新捡起来。&lt;/p>
&lt;p>Github Actions 对于个人用户来说确实是一个很棒的东西，因为它确实可以部分取代服务器，每个虚拟机的配置也足够：&lt;/p>
&lt;ul>
&lt;li>2-core CPU&lt;/li>
&lt;li>7 GB of RAM memory&lt;/li>
&lt;li>14 GB of SSD disk space&lt;/li>
&lt;/ul></description></item><item><title>RabbitMQ 学习笔记 | 二</title><link>https://ireflux.github.io/snow/post/study-note-of-rabbitmq-2/</link><pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/study-note-of-rabbitmq-2/</guid><description>&lt;p>开始填坑第二篇笔记，没想到这一隔就是将近四个月/笑。第一篇在这里：&lt;a href="https://wanmei.ml/snow/post/study-note-of-rabbitmq-1/">RabbitMQ 学习笔记(1)&lt;/a>&lt;/p>
&lt;p>对于 Spring AMQP，消息默认是持久化的，前提是消息到达的终端队列也必须是持久的。尽管是持久化的，但是在消息接收的短时间内并未保存在磁盘上，而是在内存里。&lt;/p>
&lt;p>RabbitMQ 有两种消息调度方式，一种是其默认的循环调度，即每个 consumer 都会收到相同数量的消息。另一种是公平调度，为 Spring AMQP 的默认配置。Spring AMQP 中 &lt;code>AbstractMessageListenerContainer&lt;/code> 定义的 &lt;code>DEFAULT_PREFETCH_COUNT&lt;/code> 值为 250,如果将其设置为 1,则将会变为循环调度。&lt;/p></description></item><item><title>Spring Session 使用笔记</title><link>https://ireflux.github.io/snow/post/note-on-using-spring-session/</link><pubDate>Sat, 23 Nov 2019 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/note-on-using-spring-session/</guid><description>&lt;p>Spring Session 的配置非常简单，根据&lt;a href="https://docs.spring.io/spring-session/docs/current/reference/html5/guides/boot-redis.html">官方文档&lt;/a>的说明，只需配置依赖及配置文件即可使用，无需任何代码相关的配置项。&lt;/p>
&lt;p>首先需要添加依赖项:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;span class="c">&amp;lt;!-- ... --&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.session&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>spring-session-data-redis&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>栈和队列的相互转换</title><link>https://ireflux.github.io/snow/post/stack-to-queue/</link><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/stack-to-queue/</guid><description>&lt;p>关于栈和队列，有时会在面试题中看到诸如以下的问题：&lt;/p>
&lt;ol>
&lt;li>如何使用栈实现队列？&lt;/li>
&lt;li>如何使用队列实现栈？&lt;/li>
&lt;/ol>
&lt;p>栈的特点是 last in, first out (LIFO)，而队列的特点是First-In-First-Out (FIFO)&lt;/p>
&lt;p>接下来根据和队列的特点开始分析一下，首先看第一个问题，要想用栈实现队列，则至少需要两个栈，假如用 stack1 和 stack2 分别表示这两个栈。思路如下：&lt;/p>
&lt;p>进入此 “队列” 时，需要先 push 进 stack1; pop 时如若 stack2 是非空的，则直接从 stack2 pop，如果是空的则需要将 stack1 中的元素全部 push 到 stack2 中，再进行出 pop 操作。&lt;/p></description></item><item><title>RabbitMQ 学习笔记 | 一</title><link>https://ireflux.github.io/snow/post/study-note-of-rabbitmq-1/</link><pubDate>Mon, 05 Aug 2019 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/study-note-of-rabbitmq-1/</guid><description>&lt;p>此文仅作个记录&lt;/p>
&lt;p>开始之前，首先需要安装 RabbitMQ 的服务端，由于我此次的安装环境为 Debian，根据官网所说，推荐使用 &lt;a href="https://www.rabbitmq.com/install-debian.html#apt">apt repository on Package Cloud or Bintray&lt;/a>这种方式来安装，然而在这里还是遇到了一些问题，想要安装最新的 RabbitMQ，则需要高版本的 Erlang，具体详情可以看这个关于 RabbitMQ 和 Erlang/OPT 的兼容性&lt;a href="https://www.rabbitmq.com/which-erlang.html#compatibility-matrix">表格&lt;/a>&lt;/p></description></item><item><title>Spring Data Redis 学习笔记</title><link>https://ireflux.github.io/snow/post/study-note-of-spring-data-redis/</link><pubDate>Sun, 21 Jul 2019 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/study-note-of-spring-data-redis/</guid><description>&lt;p>Redis官网上有一些推荐的 redis client，在 Java 编程语言分类下，截至发文前，有三个 client 被官方推荐，分别是：&lt;a href="https://github.com/xetorthio/jedis">Jedis&lt;/a>， &lt;a href="https://github.com/lettuce-io/lettuce-core">lettuce&lt;/a>， &lt;a href="https://github.com/mrniko/redisson">Redisson&lt;/a>， Spring Boot 2.X 中默认集成了 lettuce。&lt;/p>
&lt;p>以下是&lt;a href="https://github.com/lettuce-io/lettuce-core">官方&lt;/a>对 lettuce 的描述，摘录如下：&lt;/p>
&lt;blockquote>
&lt;p>Lettuce is a scalable thread-safe Redis client for synchronous, asynchronous and reactive usage. Multiple threads may share one connection if they avoid blocking and transactional operations such as BLPOP and MULTI/EXEC. Lettuce is built with netty. Supports advanced Redis features such as Sentinel, Cluster, Pipelining, Auto-Reconnect and Redis data models.&lt;/p>
&lt;/blockquote></description></item><item><title>Spring Boot 整合 Swagger2</title><link>https://ireflux.github.io/snow/post/spring-boot-and-swagger2/</link><pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/spring-boot-and-swagger2/</guid><description>&lt;p>关于 Spring Boot 整合 Swagger2，网络上有很多详细的文章，此文仅作个学习记录。&lt;/p>
&lt;p>首先需要引入 Swagger2 的依赖，截止发文前版本号如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>io.springfox&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>springfox-swagger2&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>2.9.2&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>io.springfox&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>springfox-swagger-ui&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>2.9.2&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>初探PostgreSQL</title><link>https://ireflux.github.io/snow/post/the-first-exploration-of-postgresql/</link><pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/the-first-exploration-of-postgresql/</guid><description>&lt;p>在群友的安利（&lt;del>传教&lt;/del>）下，成功引起了我的兴趣&amp;hellip;&lt;/p>
&lt;p>在作了一些了解之后，记录如下。以下本文的命令是在Arch Linux上进行的，其他发行版暂不作讨论，不过应该也普遍适用。&lt;/p>
&lt;p>安装没什么可说的，直接 &lt;code>sudo pacman -S postgresql&lt;/code> 就好了。(其他发行版请使用对应的包管理器)&lt;/p>
&lt;p>安装 PostgreSQL 的时候会同时创建一个名为 postgres 的系统账户。这个账户同时也是 PostgreSQL 数据库中的 Superuser, 因此创建数据库账户或者创建数据库都需要由这个账户来进行操作。&lt;/p></description></item><item><title>Docker Swarm 集群创建过程</title><link>https://ireflux.github.io/snow/post/docker-swarm-cluster-create/</link><pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/docker-swarm-cluster-create/</guid><description>&lt;p>Docker Swarm 入门用到的命令不多，初始化的时候提示写的就很详细，一步步下来感觉用起来很方便。&lt;/p>
&lt;h2 id="初始化">初始化&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ sudo docker swarm init
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Linux上adb的使用记录</title><link>https://ireflux.github.io/snow/post/adb-use-record-on-linux/</link><pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/adb-use-record-on-linux/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>我对手机的需求不高，不打游戏，只需要续航，有Google服务以及root就足够了。之前一直使用的ADUI的Global版本，再加上Magisk的root管理，配上冰箱也足以应付诸如微信这一类的国产毒瘤了。但之前有一次升级到Pie的大版本更新，把我的root覆盖掉了。因此，不得不重新再刷入Magisk。不过MIUI11官方说会加入应用冻结的功能，这样一来我连root的需求似乎也没有了 /笑&lt;/p>
&lt;p>言归正传，在Linux上使用adb有些机型还是需要做一些配置，不然 &lt;code>adb devices&lt;/code> 会显示：&lt;/p>
&lt;blockquote>
&lt;p>List of devices attached&lt;br>
[device name] unauthorized&lt;/p>
&lt;/blockquote></description></item><item><title>AVL tree 学习笔记</title><link>https://ireflux.github.io/snow/post/avl-tree-study-note/</link><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/avl-tree-study-note/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>最近在复习数据结构，学习了一下AVL树，现记录如下。&lt;/p>
&lt;h2 id="什么是avl树">什么是AVL树&lt;/h2>
&lt;p>AVL树是一种平衡二叉查找树(self-balancing binary search tree),由苏联两位科学家&lt;a href="https://en.wikipedia.org/wiki/Georgy_Adelson-Velsky">Georgy Adelson-Velsky&lt;/a>和&lt;a href="https://en.wikipedia.org/wiki/Evgenii_Landis">Evgenii Landis&lt;/a>于1962年在论文《&lt;a href="http://professor.ufabc.edu.br/~jesus.mena/courses/mc3305-2q-2015/AED2-10-avl-paper.pdf">An algorithm for the organization of information&lt;/a>》中首次提出。&lt;/p></description></item><item><title>子元素margin-top影响父元素问题</title><link>https://ireflux.github.io/snow/post/a-question-about-the-css-box-model/</link><pubDate>Thu, 10 May 2018 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/a-question-about-the-css-box-model/</guid><description>&lt;p>今天遇到了一个问题，是关于前端CSS子元素的margin-top会影响父元素的问题。搞了好长时间也不知道怎么回事，最后终于解决了，写出来权当做个记录。&lt;/p>
&lt;p>我的HTML嵌套关系如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">header&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;site-head&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">a&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;blog-logo&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">class&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;logo&amp;#34;&lt;/span> &lt;span class="na">style&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;background: url(/resources/images/qyc.jpg)&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">a&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">header&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>一道笔试题</title><link>https://ireflux.github.io/snow/post/an-interview-question/</link><pubDate>Mon, 16 Apr 2018 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/an-interview-question/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>前段时间参加了某头条的笔试，出的五道编程题都跟算法有关。其中有道题大致意思是这样的：&lt;strong>输入一个表达式，输出由‘6’这个字符组成的运算结果的图形。也就是说，假设输入5*6+6,就需要输出由‘6’组成的结果为“36”的图形。&lt;/strong>&lt;/p>
&lt;p>事实上，这道题考得是“表达式求值”。关键点就在于需要将这个表达式拆开并按照加减乘除和括号之间的优先级算法，首先需要算出具体的答案，然后取余跟事先画好的0-9的图形进行匹配即可。可惜我当时一直在想怎么表达出这些毫无规律的“数字图形”，却没意识到考点其实是&amp;lt;数据结构&amp;gt;上曾经学过的表达式求值:(&lt;/p></description></item><item><title>数据结构知识点总结</title><link>https://ireflux.github.io/snow/post/summary-of-data-structure/</link><pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/summary-of-data-structure/</guid><description>&lt;p>最近准备面试，复习一下数据结构，顺便总结下概念，加深印象，算法什么的以后慢慢补充～&lt;/p>
&lt;h1 id="树">树&lt;/h1>
&lt;p>&lt;strong>树(Tree)&lt;strong>是(n&amp;gt;=0)个节点的有限集。当n&amp;gt;0,其余节点可分为m(m&amp;gt;0)个互不相交的有限集的集合(e.g. 有限集T1,T2&amp;hellip;)，其中每个集合又是一棵树，称为根的__子树(SubTree)&lt;/strong>。节点拥有的子树的个数称为__节点的度(Degree)&lt;/strong>。
度为0的节点称为__叶子节点(Leaf)&lt;strong>或__终端节点&lt;/strong>。不为0的称为__非终端节点__或__分支节点__。节点的子树的根称为该节点的__孩子(Child)__，相应的，该节点称为孩子的__双亲(Parent)__。&lt;/p></description></item><item><title>Learn Spring Framework</title><link>https://ireflux.github.io/snow/post/learn-spring-framework/</link><pubDate>Sun, 18 Mar 2018 00:00:00 +0000</pubDate><guid>https://ireflux.github.io/snow/post/learn-spring-framework/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>Recently,I was learning the Spring Framework.&lt;/p>
&lt;p>At first, I learn it from Spring official website of the guide. When I completed the first few guides, I find that I didn’t even understand why. So I had to give up.&lt;/p>
&lt;p>After that, I looked for other guides to learn and saw many examples of IOC(Inversion of Control), DI(Dependency Injection), and AOP(Aspect Oriented Programming). I probably understand, but I still can&amp;rsquo;t use the Spirng framework. on the forum, Someone told me that I only need more practice. But I don&amp;rsquo;t even know it how to work, e.g. annotation.&lt;/p></description></item></channel></rss>